<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>服务器硬件组成和软件控制方法 | free publish as flee spark</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="服务器硬件开发的特点 相对于PC机器，服务器要求更充分的性能释放和长时间稳定运行，除了投入成本选择更好的硬件，软件上完善的驱动和基于循证的配置调优更能取得事半功倍的效果。好比我们在组装电脑的时候，都会优先选择华硕，微星和技嘉的主板，因为这三家主板BIOS的可配置项目非常多，也提供许多辅助超频的功能。x86服务器硬件开发的目标与此类似，除了不同硬件模块（CPU，内存和网卡）的匹配以保证充分协调的性能释"><meta name=generator content="Hugo 0.104.3"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css><meta property="og:title" content="服务器硬件组成和软件控制方法"><meta property="og:description" content="服务器硬件开发的特点 相对于PC机器，服务器要求更充分的性能释放和长时间稳定运行，除了投入成本选择更好的硬件，软件上完善的驱动和基于循证的配置调优更能取得事半功倍的效果。好比我们在组装电脑的时候，都会优先选择华硕，微星和技嘉的主板，因为这三家主板BIOS的可配置项目非常多，也提供许多辅助超频的功能。x86服务器硬件开发的目标与此类似，除了不同硬件模块（CPU，内存和网卡）的匹配以保证充分协调的性能释"><meta property="og:type" content="article"><meta property="og:url" content="https://flespark.github.io/posts/x86_server_hardware_component/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-07T20:11:02+08:00"><meta property="article:modified_time" content="2022-10-07T20:11:02+08:00"><meta itemprop=name content="服务器硬件组成和软件控制方法"><meta itemprop=description content="服务器硬件开发的特点 相对于PC机器，服务器要求更充分的性能释放和长时间稳定运行，除了投入成本选择更好的硬件，软件上完善的驱动和基于循证的配置调优更能取得事半功倍的效果。好比我们在组装电脑的时候，都会优先选择华硕，微星和技嘉的主板，因为这三家主板BIOS的可配置项目非常多，也提供许多辅助超频的功能。x86服务器硬件开发的目标与此类似，除了不同硬件模块（CPU，内存和网卡）的匹配以保证充分协调的性能释"><meta itemprop=datePublished content="2022-10-07T20:11:02+08:00"><meta itemprop=dateModified content="2022-10-07T20:11:02+08:00"><meta itemprop=wordCount content="6744"><meta itemprop=keywords content="x86,server,linux,"><meta name=twitter:card content="summary"><meta name=twitter:title content="服务器硬件组成和软件控制方法"><meta name=twitter:description content="服务器硬件开发的特点 相对于PC机器，服务器要求更充分的性能释放和长时间稳定运行，除了投入成本选择更好的硬件，软件上完善的驱动和基于循证的配置调优更能取得事半功倍的效果。好比我们在组装电脑的时候，都会优先选择华硕，微星和技嘉的主板，因为这三家主板BIOS的可配置项目非常多，也提供许多辅助超频的功能。x86服务器硬件开发的目标与此类似，除了不同硬件模块（CPU，内存和网卡）的匹配以保证充分协调的性能释"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">free publish as flee spark</a><div class="flex-l items-center"></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://flespark.github.io/posts/x86_server_hardware_component/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://flespark.github.io/posts/x86_server_hardware_component/&text=%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90%e5%92%8c%e8%bd%af%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%96%b9%e6%b3%95" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://flespark.github.io/posts/x86_server_hardware_component/&title=%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90%e5%92%8c%e8%bd%af%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%96%b9%e6%b3%95" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">服务器硬件组成和软件控制方法</h1><time class="f6 mv4 dib tracked" datetime=2022-10-07T20:11:02+08:00>October 7, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h3 id=服务器硬件开发的特点>服务器硬件开发的特点</h3><p>相对于PC机器，服务器要求更充分的性能释放和长时间稳定运行，除了投入成本选择更好的硬件，软件上完善的驱动和基于循证的配置调优更能取得事半功倍的效果。好比我们在组装电脑的时候，都会优先选择华硕，微星和技嘉的主板，因为这三家主板BIOS的可配置项目非常多，也提供许多辅助超频的功能。x86服务器硬件开发的目标与此类似，除了不同硬件模块（CPU，内存和网卡）的匹配以保证充分协调的性能释放，硬件选型和电路设计上也要提供一定的扩展性（网卡，显卡，加密卡，特殊加速卡的支持），较高的稳定行（电源电压和温度，风扇转速的监控，网口bypass和设备指示灯的控制）以及良好的互操作性能（远程网页管理，BMC以及其他管理接口的支持）。相比嵌入式开发，一方面服务器功能对于硬件的依赖程度相对较低。一是服务器各种行为只会用到CPU的通用计算能力，而嵌入式设备通常要和同环境交互，应对各类媒体计算和信号处理的功能，通常还有低功耗和无线通信的要求，所以CPU演变成了SoC，二是桌面处理器领域一直以来都是intel一家独大的局面，所有围绕桌面CPU的外围硬件也都只能按照<a href=https://stackoverflow.com/questions/6852332/how-does-cpu-communicate-with-peripherals title="How does cpu communicate with peripherals? - Stack Overflow">intel的规矩</a>来，使用相同的通信和控制方法。三是服务器的硬件功能的迭代要比嵌入式设备慢得多，每一代产品的变化主要是CPU性能和总线吞吐的提升，同步代产品的多个规格又仅在性能高低上有所区别。另一方面，服务器CPU为了贴近日益增长的高性能，高带宽，低延迟和高度软件兼容的市场需求，所演进的技术方案（NUMA，VT-x，SRIOV），也给软件设计带来新的机遇和挑战。总的而言，嵌入式基本是面向不同工作场景的功能定制需求，基于intel生态的服务器开发具有面向统一协议和接口，面向高并发以及虚拟化的特点。</p><h3 id=x86服务器硬件组成>x86服务器硬件组成</h3><blockquote><p>这里虽限定为x86服务器，但是依托国内的信创政策导向， 许多国产的非x86架构服务器（华为鲲鹏，飞腾，龙芯）也占据了一部分的市场。为了兼容现有的x86软件生态，硬件组成上非常相似</p></blockquote><p>和大多数嵌入式数码产品一样，虽然服务器也在向着高度集成化的方向发展，但始终保持一定的扩展性。最基本的，至少具备扩展内存和外存的能力。我们都知道内存是直接与CPU通信的，但是各种外存使用的不同的通信协议（SATA，NVME， SAS），他们是怎样和CPU通信的呢。按照intel制定的规矩，x86上所有的高速硬件控制器都应该通过PCI接口与CPU通信，以获取最大的带宽和控制到最小的延迟。所以几乎所有的服务器都提供了PCI接口，用于连接网卡，外存控制器，显卡或者其他加速卡。对于较为高端的服务器，从CPU无法引出足够的PCI接口，就要借助芯片组（业内叫法intel称之为PCH，Platform Controller Hub，AMD称为FCH，Fusion Controller Hub，是主板上一块集成了众多控制器的面积较大的芯片），将CPU提供的DMI接口拓展为多个PCI接口，并提供额外的SATA，USB，网口接口，以及其他低速接口（串口，SPI，I2C等）和系统管理相关的功能。在组装台式家用电脑时，会有价格相差极大的许多型号的主板可供选择，例如支持intel 12代酷睿芯片的常见主板型号就有H610，B660， Z690，主板型号就指示主板上面的PC用芯片组型号。服务器的平台型号也指示了主板所使用的芯片组型号，例如常见的C3000，P620，P5000平台。芯片组只是扩展CPU接口的作用，对于低端服务器CPU提供的引脚就足够用了就不是必须的，但是一些系统必须的监控和管理功能，CPU无法提供，就要用到SuperIO芯片。即便是相对简单SuperIO芯片上也集成很多低速控制器。相对嵌入式产品而言服务器对于硬件成本是不敏感的，芯片提供的许多功能可能硬件电路上就没有引出或者软件上也没有实现。另外很多中高端服务器面板都可以看到一个类似于网口的IPMI接口，IPMI是独立于操作系统或者说CPU自行运作的管理接口，直接连接到单独的BMC芯片，BMC芯片和SuperIO功能有许多重合部分，但是多了一个以太网控制器以提供IPMI互联的能力，方便服务器集群的管理。总的来说，因为服务器上单个芯片的集成度更高，所以硬件组成上更为简单。</p><h3 id=x86硬件驱动的实现>x86硬件驱动的实现</h3><p>提到x86硬件的驱动开发，你可能会关联到BIOS开发，好像操作系统层的驱动需要做的开发工作很少。这是因为x86过程中有一个实模式的阶段，BIOS一般都工作在实模式，按照intel的约定，BIOS中需要配置基本的驱动功能，然后把硬件信息按照ACPI和SMBIOS规范以特定格式保存在内存中的固定位置，操作系统启动后可以从这些位置获取到硬件的基本信息，或者根据这些信息对硬件做进一步的配置。其实现是，在操作系统层面，驱动从ACPI获取硬件寄存器在低端内存中的映射的位置，然后根据硬件的datasheet操作到想要的寄存器。前面提到目前阶段x86架构的所有硬件都是一级一级地挂在在PCI总线上，所以操作系统驱动也可以不使用ACPI提供的信息，直接从PCI配置空间获取硬件寄存器在低端内存中的映射。以下驱动配置的介绍均基于这种控制方法。</p><h3 id=pci>PCI</h3><p>PCI总线提供了外围设备与CPU高速通信的能力，是目前的intel的标准总线规范，PCIE是PCI的升级版，物理通信方式从并行改为了串行，增强了中断功能。PCI早已淘汰，目前主板能看到的都是PCIE插槽，这里只涉及PCI和PCIE通用的基本软件控制方式，所以以下不加区分。CPU通过总线号(8bit数据表示)，设备号(5bit)，功能号（3bit）[bus:dev.func]定位每一个PCI设备的功能单元（一个功能单元代表一个最小可独立配置硬件，例如一个4口网卡，每个网口分配一个功能号，设备号是一样的），在Linux上执行lspci列出系统识别到的每一个PCI设备，可以看到大多数PCI设备的总线号都为0，其他不为0的总线通过PCI桥的桥接的设备的总线号根据<a href=https://mp.weixin.qq.com/s/ulSSIRiOFGPeY6s7_kHuNg title=一文梳理PCIe技术原理>深度优先遍历的顺序枚举</a>，执行lspci -tv可以列出PCI设备的拓扑树。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>root@edge-xnet:~/Desktop# lspci
</span></span><span style=display:flex><span>00:00.0 Host bridge: Intel Corporation Gemini Lake Host Bridge <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:02.0 VGA compatible controller: Intel Corporation GeminiLake <span style=color:#f92672>[</span>UHD Graphics 600<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:0e.0 Audio device: Intel Corporation Celeron/Pentium Silver Processor High Definition Audio <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:0f.0 Communication controller: Intel Corporation Celeron/Pentium Silver Processor Trusted Execution Engine Interface <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:12.0 SATA controller: Intel Corporation Celeron/Pentium Silver Processor SATA Controller <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:13.0 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:13.1 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:13.2 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:13.3 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:14.0 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:14.1 PCI bridge: Intel Corporation Gemini Lake PCI Express Root Port <span style=color:#f92672>(</span>rev f6<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:15.0 USB controller: Intel Corporation Celeron/Pentium Silver Processor USB 3.0 xHCI Controller <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:1f.0 ISA bridge: Intel Corporation Celeron/Pentium Silver Processor LPC Controller <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>00:1f.1 SMBus: Intel Corporation Celeron/Pentium Silver Processor Gaussian Mixture Model <span style=color:#f92672>(</span>rev 06<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>01:00.0 Ethernet controller: Intel Corporation Ethernet Controller I225-V <span style=color:#f92672>(</span>rev 03<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>02:00.0 Ethernet controller: Intel Corporation Ethernet Controller I225-V <span style=color:#f92672>(</span>rev 03<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>03:00.0 Ethernet controller: Intel Corporation Ethernet Controller I225-V <span style=color:#f92672>(</span>rev 03<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>04:00.0 Ethernet controller: Intel Corporation Ethernet Controller I225-V <span style=color:#f92672>(</span>rev 03<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>06:00.0 Network controller: Intel Corporation Device <span style=color:#ae81ff>2725</span> <span style=color:#f92672>(</span>rev 1a<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>root@edge-xnet:~/Desktop# lspci -tv
</span></span><span style=display:flex><span>-<span style=color:#f92672>[</span>0000:00<span style=color:#f92672>]</span>-+-00.0  Intel Corporation Gemini Lake Host Bridge
</span></span><span style=display:flex><span>           +-02.0  Intel Corporation GeminiLake <span style=color:#f92672>[</span>UHD Graphics 600<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>           +-0e.0  Intel Corporation Celeron/Pentium Silver Processor High Definition Audio
</span></span><span style=display:flex><span>           +-0f.0  Intel Corporation Celeron/Pentium Silver Processor Trusted Execution Engine Interface
</span></span><span style=display:flex><span>           +-12.0  Intel Corporation Celeron/Pentium Silver Processor SATA Controller
</span></span><span style=display:flex><span>           +-13.0-<span style=color:#f92672>[</span>01<span style=color:#f92672>]</span>----00.0  Intel Corporation Ethernet Controller I225-V
</span></span><span style=display:flex><span>           +-13.1-<span style=color:#f92672>[</span>02<span style=color:#f92672>]</span>----00.0  Intel Corporation Ethernet Controller I225-V
</span></span><span style=display:flex><span>           +-13.2-<span style=color:#f92672>[</span>03<span style=color:#f92672>]</span>----00.0  Intel Corporation Ethernet Controller I225-V
</span></span><span style=display:flex><span>           +-13.3-<span style=color:#f92672>[</span>04<span style=color:#f92672>]</span>----00.0  Intel Corporation Ethernet Controller I225-V
</span></span><span style=display:flex><span>           +-14.0-<span style=color:#f92672>[</span>05<span style=color:#f92672>]</span>--
</span></span><span style=display:flex><span>           +-14.1-<span style=color:#f92672>[</span>06<span style=color:#f92672>]</span>----00.0  Intel Corporation Device <span style=color:#ae81ff>2725</span>
</span></span><span style=display:flex><span>           +-15.0  Intel Corporation Celeron/Pentium Silver Processor USB 3.0 xHCI Controller
</span></span><span style=display:flex><span>           +-1f.0  Intel Corporation Celeron/Pentium Silver Processor LPC Controller
</span></span><span style=display:flex><span>           <span style=color:#ae81ff>\-</span>1f.1  Intel Corporation Celeron/Pentium Silver Processor Gaussian Mixture Model
</span></span></code></pre></div><p>拓扑树中4个网口（Ethernet Controller I225-V）分别通过4个PCI桥连接到CPU，即HOST bridge。PCI桥的总线地址是确认的，那么如何确认其所连接次级总线的PCI总线号呢，这里先要介绍PCI的配置空间。每个PCI设备都有256字节的配置空间，以每个寄存器32bits大小的形式对齐访问。其中前4个寄存器有着相同的标识功能，后面寄存器的数据区分设备类型表示不同的<a href=https://wiki.osdev.org/Acpi title="PCI - OSDev Wiki">含义</a>。Linux系统访问PCI设备的配置空间有2种方式。</p><p>第一种方式：直接从低端IO空间读写PCI寄存器的数据，参考代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>pciConfigReadWord</span>(<span style=color:#66d9ef>uint8_t</span> bus, <span style=color:#66d9ef>uint8_t</span> slot, <span style=color:#66d9ef>uint8_t</span> func, <span style=color:#66d9ef>uint8_t</span> offset) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> address;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> lbus  <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)bus;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> lslot <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)slot;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> lfunc <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)func;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> tmp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create configuration address as per Figure 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    address <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)((lbus <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>) <span style=color:#f92672>|</span> (lslot <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>11</span>) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>              (lfunc <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>|</span> (offset <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>|</span> ((<span style=color:#66d9ef>uint32_t</span>)<span style=color:#ae81ff>0x80000000</span>));
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write out the address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    outl(<span style=color:#ae81ff>0xCF8</span>, address);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read in the data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (offset &amp; 2) * 8) = 0 will choose the first word of the 32-bit register
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    tmp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint16_t</span>)((inl(<span style=color:#ae81ff>0xCFC</span>) <span style=color:#f92672>&gt;&gt;</span> ((offset <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFF</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tmp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第二种方式：从<a href=https://www.kernel.org/doc/html/latest/PCI/sysfs-pci.html title="Accessing PCI device resources through sysfs">sysfs</a>中获取，参考代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>pciConfigReadWord</span>(<span style=color:#66d9ef>uint8_t</span> bus, <span style=color:#66d9ef>uint8_t</span> slot, <span style=color:#66d9ef>uint8_t</span> func, <span style=color:#66d9ef>uint8_t</span> offset) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> pci_path[PCI_PATH_LENGTH];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> reg_val;
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(__x86_64__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#define PCI_PATH_PATTERN &#34;/sys/bus/pci/devices/0000:%02x:%02x.%1x/config&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#elif defined(__aarch64__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#define PCI_PATH_PATTERN &#34;/sys/bus/pci/devices/pci0000:%02x:%02x.%1x/config&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    snprintf(pci_path, PCI_PATH_LENGTH <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, PCI_PATH_PATTERN,
</span></span><span style=display:flex><span>        bus, dev, func);
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> open(pci_path, O_RDWR <span style=color:#f92672>|</span> O_SYNC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    lseek(fd, offset <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xfc</span>, SEEK_SET);
</span></span><span style=display:flex><span>    read(fd, <span style=color:#f92672>&amp;</span>reg_val, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    close(fd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reg_val;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或使用lspci或者<a href=https://www.man7.org/linux/man-pages/man8/setpci.8.html title="setpci(8) -Linux manual page">setpci</a>,<a href="http://www.armadeus.org/wiki/index.php?title=Pci_debug" title="Pci debug -ArmadeusWiki">pci_debug</a>命令读写PCI配置空间和内存映射寄存器的内容。</p><p>读写PCI的配置空间首先需要确定设备的PCI地址，但是接在PCI桥上设备的PCI的总线地址不是固定的。常见的PCI桥有2中，一种Host Bridge，一种PCI-to-PCI Bridge，Host Bridge的插槽上的每一个设备的总线号对应Host Bridge一个新的功能号，PCI-to-PCI Bridge的功能号个数是固定的，读取PCI配置空间的Class code可以区分Bridge类型。对于Bridge类型的PCI设备配置空间的Subordinate bus number则保存着次级设备的总线号，PCI插槽在接入新设备时，设备号和功能号都是固定的，通过读取该寄存器中的内容确认新设备的总线号确认新设备的PCI地址。</p><p><a href=https://wiki.osdev.org/PCI_Express#Enhanced_Configuration_Mechanism title="PCI Express">PCIE</a>较之PCI地址中多了一个PCI域（segment group number）的部分，设备的配置空间升级到了4096字节的大小，前面的256字节和PCI一样可以通过上面PCI的传统方式访问，但是扩展的部分（包括PCI域不是默认0设备）的寄存器，x86设备通过BIOS传递的ACPI中的MCFG表获取配置空间在内核中的映射地址，其他架构系统则一般通过设备树的方式。</p><p>BIOS通过操作配置空间只完成的PCI层面的配置（包括PCI的设备ID，PCI地址，速率，中断号分配），况且系统启动之后这块内容被置为只读。功能层面（对应各种外围设备控制器，例如SMBus控制器，NvMe控制器，MAC芯片）则是通过对多个BAR（Base Address Register）映射位置的内存来完成配置，BAR可以在配置空间获取到，Endpoint设备的配置空间有5个BAR，Bridge设备配置空间只有2个BAR。Linux中内核驱动代码主要配置这部分内存中的数据，但是驱动加载成功之后，PCI与CPU的通信就是走的DMA通道。</p><p>PCI总线枚举和设备识别是在BIOS中进行的，B主板IOS配置页面可以找到PCI的速率，中断模式，电源管理的一些基础配置项，有的BIOS固定把部分PCI桥的次级设备设置的固定bus_num。进入Linux系统后，一般通过一个lspci就可以读取大致的的PCI设备工作状态，</p><h3 id=superio>SuperIO</h3><p><a href=https://web.archive.org/web/20210415014544/https://www.coreboot.org/Developer_Manual/Super_IO title="Developer Manual/Super IO - coreboot">SuperIO</a>多在工控机和低端服务器以及一些x86嵌入式设备上比较常见，是x86在ISA总线架构留下的产物，理应该被淘汰了。而且SuperIO和现代桌面CPU所能提供的功能有一部分的重叠，但是很多低端机上还是有用到SuperIO，一方面作为替代PCH的低成本选项<a href=https://en.wikipedia.org/wiki/Super_I/O title="Super I/O - Wikipedia">扩展低速接口控制器和引脚</a>，另一方面在多种产品中使用相同的SuperIO也减少了硬件制版和软件适配上的开销。SuperIO提供的低速总线扩展，包括串口接入，SMBus/I2C接口，温度传感器，风扇转速控制，供电电压监控，看门狗中断，红外信号接收，PS/2键鼠接口等几乎所有的低速总线功能，不同型号所支持的功能和对应接口数量差异也比较大，具体以厂商提供的datasheet位置。以前SuperIO是通过ISA总线与CPU交互数据的，现在多数通过LPC接口与CPU进行通信，但是软件上还是沿用原来直接读写IO端口的控制方式。因为只有x86架构支持IO端口命令，所以几乎也只能在x86平台服务器中找到SuperIO芯片。通过2个映射到特定IO端口的寄存器，读写SuperIO每个对应功能的对应配置寄存器：</p><ul><li><p>索引寄存器（大多数芯片映射到0x2E的位置，少部分映射到0x4E）</p></li><li><p>数据寄存器（大多数映射到0x2F位置，少部分映射到0x4F）</p></li></ul><p>首先往索引寄存器端口写入想要读写寄存器的索引值，然后数据寄存器端口就可以读写到想要的数据。SuperIO读写一个配置寄存器往往需要经过多层索引，首先芯片的每一个功能模块（比如温度传感器1）占据一段IO端口地址段，他们的起始地址可以通过LDN（Logic Device Number）定位，流程如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>outb(<span style=color:#ae81ff>0x20</span>, index_reg);  <span style=color:#75715e>//基偏移为0x20位置的寄存器，对应SuperIO的ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> id <span style=color:#f92672>=</span> inb(data_reg); <span style=color:#75715e>//保存ID，确认芯片型号识别正确
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>outb(<span style=color:#ae81ff>0x07</span>, index_reg);  <span style=color:#75715e>//基偏移为0x07的寄存器，对应LDN选择寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>outb(<span style=color:#ae81ff>0x03</span>, data_reg);   <span style=color:#75715e>//选择LDN 0x03
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>out(<span style=color:#ae81ff>0x30</span><span style=color:#960050;background-color:#1e0010>，</span> index_reg);  <span style=color:#75715e>//选择LDN偏移为0x30的使能寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>outb(<span style=color:#ae81ff>0x01</span>, data_reg);   <span style=color:#75715e>//使能对应的功能
</span></span></span></code></pre></div><p>有的SuperIO控制流程更复杂一些，在写入寄存器之前有固定的entry instruction，并且把多个功能单元合并到一个LDN访问，以下代码示例借助<a href=https://people.redhat.com/rjones/ioport/ title="ioport - direct access to I/O ports from the command line">ioport</a>控制ITE8772E SuperIO的PWM风扇1转速：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># entry instru</span>
</span></span><span style=display:flex><span>it87_entry<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>outb 0x2e 0x87
</span></span><span style=display:flex><span>outb 0x2e 0x01
</span></span><span style=display:flex><span>outb 0x2e 0x55
</span></span><span style=display:flex><span>outb 0x2e 0x55
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># select LDN</span>
</span></span><span style=display:flex><span>EU_probe<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#75715e># select EU(Environment Controller Unit)</span>
</span></span><span style=display:flex><span>outb 0x2e 0x07
</span></span><span style=display:flex><span>outb 0x2f 0x04
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># read EU activate register</span>
</span></span><span style=display:flex><span>outb 0x2e 0x30
</span></span><span style=display:flex><span>tmp<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>inb 0x2f<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $? -ne <span style=color:#ae81ff>0</span> <span style=color:#f92672>]]</span> <span style=color:#f92672>||</span> <span style=color:#f92672>[[</span> <span style=color:#66d9ef>$((</span> $tmp <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0</span>x01 <span style=color:#66d9ef>))</span> -ne <span style=color:#ae81ff>1</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>	printf <span style=color:#e6db74>&#34;IT87 not activited!\n&#34;</span>
</span></span><span style=display:flex><span>	exit
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># read EU base register address</span>
</span></span><span style=display:flex><span>outb 0x2e 0x60
</span></span><span style=display:flex><span>base_addr<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>inb 0x2f<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>base_addr<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span> base_addr <span style=color:#e6db74>&lt;&lt; 8 ))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>outb 0x2e 0x61
</span></span></span><span style=display:flex><span><span style=color:#e6db74>base_addr=$(( base_addr | $(inb 0x2f) ))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>echo $base_addr
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>get_fan_ctl_reg() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>if (($# &lt; 1)); then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	echo &#34;not designated base addr in arg&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	exit 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>base_addr=$1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74># get EU address map in LPC bus
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EU_addr=$(( base_addr + 0x05 ))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EU_data=$(( base_addr + 0x06 ))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>if [[ -n $targetVal ]]; then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	# set fan1 software control mode
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	outb $EU_addr 0x16
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	outb $EU_data 0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	# set fan1 PWM duty value(per 256)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	outb $EU_addr 0x6b
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	outb $EU_data $targetVal
</span></span></span><span style=display:flex><span><span style=color:#e6db74>fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>outb $EU_addr 0x6b
</span></span></span><span style=display:flex><span><span style=color:#e6db74>fanOutput1=$(inb $EU_data)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>printf &#34;fan1 output 0x%x\n&#34; &#34;$fanOutput1&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74># exit instru
</span></span></span><span style=display:flex><span><span style=color:#e6db74>it8</span><span style=color:#ae81ff>7</span>_exit<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>outb <span style=color:#ae81ff>0</span>x2e <span style=color:#ae81ff>0</span>x02
</span></span><span style=display:flex><span>outb <span style=color:#ae81ff>0</span>x2f <span style=color:#ae81ff>0</span>x02
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main<span style=color:#f92672>()</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>	it87_entry
</span></span><span style=display:flex><span>	base_addr<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>EU_probe<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>$# <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>	targetVal<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span> $1 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0</span>xff <span style=color:#66d9ef>))</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>	get_fan_ctl_reg $base_addr
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	it87_exit
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main $@
</span></span></code></pre></div><p>很多SuperIO可以找到对应的内核模块，加载后通过sysfs控制SuperIO寄存器的是一种更规范的行为，下面的守护进程每隔5秒读取一次SuperIO的温度传感器的数据调整风扇的转速：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>tweak_fan<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        sio_temp<span style=color:#f92672>=</span><span style=color:#66d9ef>$(($(</span>cat temp2_input<span style=color:#66d9ef>)</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span><span style=color:#66d9ef>))</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>sio_temp &lt; 45<span style=color:#f92672>))</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            echo <span style=color:#ae81ff>32</span> &gt; pwm2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>((</span>sio_temp &lt; 55<span style=color:#f92672>))</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            echo <span style=color:#ae81ff>64</span> &gt; pwm2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>((</span>sio_temp &lt; 65<span style=color:#f92672>))</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            echo <span style=color:#ae81ff>128</span> &gt; pwm2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            echo <span style=color:#ae81ff>255</span> &gt; pwm2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>        sleep <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    modprobe it87 <span style=color:#f92672>||</span> exit -1
</span></span><span style=display:flex><span>    cd /sys/class/hwmon/hwmon2
</span></span><span style=display:flex><span>    tweak_fan &gt; /dev/null
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main &amp;
</span></span></code></pre></div><p>想要知道主板上是否有SuperIO芯片，除了打开机箱找到芯片，<a href=https://github.com/lm-sensors/lm-sensors title="github: lm-sensors">lm-sensor</a>提供的sensors-detect工具多数情况下也可以正确识别。对于一些后期推出不太流行的SuperIO芯片，sensors-detect的识别结果就仅供参考，但BIOS的配置菜单不会骗人。虽然SuperIO提供的众多功能单元，但是硬件上引出有效连线不会很多，把SuperIO利用起来都要经过一些手动测试。在内核中加入一款SuperIO的支持并不困难，只要参考相似型号的已有代码，基于<a href=https://www.kernel.org/doc/html/latest/hwmon/hwmon-kernel-api.html title="The Linux Hardware Monitoring Kernel API">hwmon</a>做一些配置修改的琐碎工作，所以这部分内核代码最近都没什么人改动。</p><h3 id=pch>PCH</h3><p>从英特尔推出酷睿处理器开始，内存控制器集成到了CPU内部，主板中就没有了北桥这一说，PCH就继承了南桥的功能。按以往南桥连接低速总线的说法也是相对的，PCH也提供了多路PCIe，千兆网卡的高速连接能力。intel PCH与CPU之间通信是通过一种类PCI的DMI高速总线，PCH支持的系统监控能力比SuperIO更加丰富，所以和CPU之间还有额外的许多中断线连接。受限于DMI总线的带宽，PCH必须在其提供的各种高速总线接入功能（PCIe，USB，GbE，SATA）中做出取舍，这部分控制结构称之为HSIO（Flexible IO）。反映到PC主板上，如果把所有的SATA接口插满的话，通过PCH桥接的PCIe口就没法用了。PCH所提供的低速接口和SuperIO区别不大，但是控制上多数是基于PCI总线，也就是需要从PCI配置空间获取BAR，然后才可以操作具体的寄存器，具体参考intel提供的datasheet。</p><h3 id=smbusi2c>SMbus/I2C</h3><p>SMBus是intel基于I2C协议新增网络层控制层而推出的一种总线协议，虽然在虽然在物理层面也有一些区别，但是SMBus是完全兼容I2C的软件框架的。SMBus一般只出现在intel x86的机器上（CPU，PCH或者SuperIO带有SMBus控制器），而国产化平台上则换成了I2C，无歧义的情况下这里统称I2C。I2C可以连接一些低速外围部件，例如EEPROM、GPIO扩展板、继电器，常留给下游厂商或者部门做一些产线的区分和个性化定制（俗话说科技以换壳为本）。I2C作为最常用的总线协议之一，内核是提供了标准的ioctl接口和调试工具i2c-tools，所以基于已有内核驱动控制I2C设备相对简单，intel x86平台的SMBus控制器也可以通过IO端口控制。在一些的系统上，每个I2C设备驱动加载的顺序不是固定的，导致/dev目录的命名可能在启动后会变动。但是控制器的编号是固定的。所以要通过sysfs定位定位到对应的控制器。在设备带有多个网卡插槽的情况下，I2C控制器通过一个I2C Mux连接到多张网卡的EEPROM。I2C Mux一般提供了控制地址和转发地址，读写定路由地址可以控制I2C Mux选路，读写路由地址则相当于直接与选通的末端网卡通信。另外，由于一个I2C控制是可能连接到多个设备，或者作为接口提供服务的情况下，内部需要做好访问互斥控制，不然可能会导致一些难以排查的bug。</p><h3 id=高并发与负载均衡>高并发与负载均衡</h3><p>TODO</p><h3 id=intel虚拟化技术>Intel虚拟化技术</h3><p>TODO</p><ul class=pa0><li class=list><a href=/tags/x86 class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">x86</a></li><li class=list><a href=/tags/server class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">server</a></li><li class=list><a href=/tags/linux class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">linux</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3"></p><ul class="pa0 list"><li class=mb2><a href=/posts/rock_pi_e_config_introduction/>Rock_Pi_E_config_introduction</a></li><li class=mb2><a href=/posts/android_sdk_index_config/>使用vscode配置Android BSP开发环境</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://flespark.github.io>&copy; CC BY-NC-ND 4.0 2022</a><div></div></div></footer></body></html>